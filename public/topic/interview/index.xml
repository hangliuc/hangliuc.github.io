<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>面试 on hangliuc</title>
        <link>http://localhost:1313/topic/interview/</link>
        <description>Recent content in 面试 on hangliuc</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Sat, 06 Dec 2025 09:56:07 +0800</lastBuildDate><atom:link href="http://localhost:1313/topic/interview/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Docker</title>
        <link>http://localhost:1313/topic/interview/docker/</link>
        <pubDate>Sat, 06 Dec 2025 09:56:07 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/docker/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Docker" /&gt;&lt;h2 id=&#34;1容器技术的基础原理&#34;&gt;1.容器技术的基础原理
&lt;/h2&gt;&lt;p&gt;容器技术的基础原理是基于 Linux 内核的 Namespace 和 Cgroups 技术。&lt;/p&gt;
&lt;p&gt;解决问题：最初解决本地与云端不一致版本问题&lt;/p&gt;
&lt;p&gt;容器镜像：利用Linux的Union FS技术，将应用程序所依赖的运行操作系统、工具包、依赖库、配置文件、运行脚本等各种环境信息以分层的方式联合挂载到同一个目录下，作为镜像的根目录&lt;/p&gt;
&lt;h2 id=&#34;2如何减dockerfile成镜像体积多阶段构建&#34;&gt;2.如何减⼩dockerfile⽣成镜像体积（多阶段构建）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用更小的基础镜像&lt;/li&gt;
&lt;li&gt;构建环境（编译器、依赖）与运行环境分离&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 第一阶段：编译&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;golang:1.22-alpine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;/app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; go build -o app .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 第二阶段：运行&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;alpine:3.19&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; --from&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;builder /app/app /usr/local/bin/app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;app&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;及时清理构建缓存、临时文件&lt;/li&gt;
&lt;li&gt;合并 RUN 指令，减少镜像层数&lt;/li&gt;
&lt;li&gt;不要复制整个项目 → 精准 COPY&lt;/li&gt;
&lt;li&gt;使用 .dockerignore，避免复制不必要的文件&lt;/li&gt;
&lt;li&gt;&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3容器网络模式&#34;&gt;3.容器网络模式
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;bridge：默认模式，容器之间可以通过 IP 通信，外部可以通过端口映射访问容器&lt;/li&gt;
&lt;li&gt;host：容器与主机共享网络栈，容器直接使用主机的 IP 和端口&lt;/li&gt;
&lt;li&gt;none：容器没有网络，只能使用 localhost 访问&lt;/li&gt;
&lt;li&gt;container：容器与另一个容器共享网络栈，容器之间可以直接通过 IP 通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4docker和container区别&#34;&gt;4.docker和container区别
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker：是一个容器引擎，用于创建、运行、管理容器&lt;/li&gt;
&lt;li&gt;container：是一个运行中的进程，是一个独立的、可执行的软件包，包含应用程序和其依赖的运行环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;架构层面的原因&#34;&gt;架构层面的原因
&lt;/h3&gt;&lt;p&gt;kubelet 启动一个容器的流程:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubelet
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 CRI 接口&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dockershim &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;K8s 维护的 CRI 转换层&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 Docker Engine API&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Docker Engine
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 containerd API&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;containerd
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 OCI 接口&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;runc &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;OCI runtime&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; └─&amp;gt; 真正创建 Linux 容器 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;namespace, cgroups, rootfs...&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Docker Engine 是一个 完整平台（构建镜像、管理网络、Volume、Swarm 等），这些对 K8s 来说都是多余的。&lt;/li&gt;
&lt;li&gt;dockershim 只是为了把 CRI（K8s 语言）翻译成 Docker API（Docker 语言）。&lt;/li&gt;
&lt;li&gt;实际执行容器的，依然是 containerd + runc。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 kubelet 直接使用 containerd 时，调用链简化为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; kubelet
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 CRI 接口&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;containerd &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;内置 CRI 插件&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  │ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;调用 OCI 接口&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;runc &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;OCI runtime&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  └─&amp;gt; 真正创建 Linux 容器 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;namespace, cgroups, rootfs...&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;减少维护成本&#34;&gt;减少维护成本
&lt;/h3&gt;&lt;p&gt;kubernetes 从 1.24 开始，默认使用 containerd 作为容器运行时。不再去维护中间dockershim&lt;/p&gt;
&lt;h3 id=&#34;性能提升&#34;&gt;性能提升
&lt;/h3&gt;&lt;p&gt;少一层调用，性能和稳定性更好。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>http://localhost:1313/topic/interview/monitoring/</link>
        <pubDate>Fri, 05 Dec 2025 13:38:56 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/monitoring/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Monitoring" /&gt;&lt;h2 id=&#34;1监控指标类型及应用场景&#34;&gt;1.监控指标类型及应用场景
&lt;/h2&gt;&lt;p&gt;1、 计数器（Counter）：用于记录事件的数量，例如请求次数、错误次数等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：单调递增，只增不减，重启时被设置为0&lt;/li&gt;
&lt;li&gt;场景：qps、error、已经完成的任务数等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、 计量器（Gauge）：用于记录当前的数值，例如内存使用量、CPU 利用率等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：可增可减，可以任意变化的指标&lt;/li&gt;
&lt;li&gt;场景：cpu、mem、disk、network等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Histogram和Summary主用用于计算分位数，统计和分析样本的分布情况。&lt;/p&gt;
&lt;p&gt;3、 直方图（Histogram）：用于记录事件的分布情况，Prometheus 服务端通过 bucket 计算分位数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：要提前定义 bucket（如 10ms、50ms、100ms…），用于将样本值分桶。可以聚合跨实例的全局分位数（Summary 做不到）&lt;/li&gt;
&lt;li&gt;场景：业务接口延迟监控，p95、p99&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;histogram_quantile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;http_request_duration_seconds_bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;by&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;le&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;4、 摘要（Summary）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：不需要 bucket，代码内自动维护 quantile。无法跨实例计算全局 p99
如果你有 10 个 pod，各自暴露 p99，那么 Prometheus 不能再算“整个服务的 p99”&lt;/li&gt;
&lt;li&gt;场景：每个实例都独立的统计需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Summary 的分位数是在客户端（应用）本地计算的，Prometheus 只需存储最终的 p95、p99 数值。但是不能聚合跨实例的全局分位数。
Histogram在服务端计算分位数，Histogram 能够将多个实例的数据聚合在一起，得出整个服务的全局分位数，是k8s生产环境最常用的方式。&lt;/p&gt;
&lt;h2 id=&#34;2-黄金指标&#34;&gt;2. 黄金指标
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;延迟（Latency）&lt;/li&gt;
&lt;li&gt;qps&lt;/li&gt;
&lt;li&gt;错误率（Error Rate）&lt;/li&gt;
&lt;li&gt;饱和度（Saturation）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Network</title>
        <link>http://localhost:1313/topic/interview/network/</link>
        <pubDate>Thu, 04 Dec 2025 19:36:01 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/network/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Network" /&gt;&lt;h2 id=&#34;1osi七层模型&#34;&gt;1.OSI七层模型
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;发送端（电脑A）                          接收端（电脑B）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+----------------+                      +----------------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 应用层：Data   |                      | 应用层：Data   |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|  &amp;#34;Hi&amp;#34;          |                      |  &amp;#34;Hi&amp;#34;          |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 表示层：Data + 表示头                    表示层：Data（剥离表示头）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 会话层：Data + 会话头                    会话层：Data（剥离会话头）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 传输层：Segment（Data + 端口头）        传输层：Data（剥离端口头）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 网络层：Packet（Segment + IP头）       网络层：Segment（剥离IP头）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 数据链路层：Frame（Packet + MAC头 + CRC）数据链路层：Packet（剥离MAC头+CRC）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| 物理层：Bits（Frame转换）               物理层：Frame（Bits转换）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-------+--------+                      +-------^--------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        +---------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               物理介质（网线/无线）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;OSI 层&lt;/th&gt;
          &lt;th&gt;核心功能&lt;/th&gt;
          &lt;th&gt;关键设备 / 组件&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;应用层&lt;/td&gt;
          &lt;td&gt;提供应用程序之间的通信&lt;/td&gt;
          &lt;td&gt;浏览器、FTP客户端、SMTP客户端&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;表示层&lt;/td&gt;
          &lt;td&gt;数据的表示和转换&lt;/td&gt;
          &lt;td&gt;加密、压缩&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;会话层&lt;/td&gt;
          &lt;td&gt;管理会话连接&lt;/td&gt;
          &lt;td&gt;会话ID&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;传输层&lt;/td&gt;
          &lt;td&gt;端到端通信&lt;/td&gt;
          &lt;td&gt;TCP、UDP&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;网络层&lt;/td&gt;
          &lt;td&gt;跨网络路由与 IP 地址识别&lt;/td&gt;
          &lt;td&gt;路由器、交换机&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;数据链路层&lt;/td&gt;
          &lt;td&gt;帧传输与 MAC 地址识别&lt;/td&gt;
          &lt;td&gt;网卡、交换机&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;物理层&lt;/td&gt;
          &lt;td&gt;比特流传输&lt;/td&gt;
          &lt;td&gt;网线、光纤&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2http11-和http2-区别&#34;&gt;2.http1.1 和http2 区别
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;HTTP/1.1&lt;/th&gt;
          &lt;th&gt;HTTP/2&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;传输开销&lt;/td&gt;
          &lt;td&gt;文本传输，开销较大&lt;/td&gt;
          &lt;td&gt;二进制流传输，开销更小&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;多路复用&lt;/td&gt;
          &lt;td&gt;顺序加载资源，某个资源阻塞会影响后续资源&lt;/td&gt;
          &lt;td&gt;单个 TCP 连接上可以同时发送多个数据流，互不阻塞&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;服务器推送&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持，服务器可在客户端请求之前推送内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;标头压缩&lt;/td&gt;
          &lt;td&gt;不压缩或简单压缩，冗余信息多&lt;/td&gt;
          &lt;td&gt;使用 HPACK 压缩，减少冗余，提高加载速度&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3tcp-的链接状态&#34;&gt;3.TCP 的链接状态
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/interview/tcp_netstat.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;4为什么tcp是三次握手&#34;&gt;4.为什么TCP是三次握手
&lt;/h2&gt;&lt;p&gt;因为三次握手才能保证双方具有接收和发送的能力。&lt;/p&gt;
&lt;h3 id=&#34;为什么不是-2-次握手&#34;&gt;为什么不是 2 次握手
&lt;/h3&gt;&lt;p&gt;假设需要两次&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 SYN&lt;/li&gt;
&lt;li&gt;服务器返回 ACK&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;假设网络拥塞中存在延迟或丢包，一个 旧的 SYN 报文残留在网络中。&lt;/li&gt;
&lt;li&gt;服务器收到残留 SYN，误认为客户端要建立新连接，返回 ACK。&lt;/li&gt;
&lt;li&gt;客户端收到 ACK，误以为连接已建立，继续发送数据。&lt;/li&gt;
&lt;li&gt;服务器收到数据，误以为是新连接的流量，错误处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么不是-4-次或更多&#34;&gt;为什么不是 4 次或更多？
&lt;/h3&gt;&lt;p&gt;3 次已经足以建立连接，4 次或更多次握手会增加复杂性和资源浪费&lt;/p&gt;
&lt;h2 id=&#34;5dns-解析流程&#34;&gt;5.DNS 解析流程
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本地host 映射（优先级最高，如果有记录直接返回）&lt;/li&gt;
&lt;li&gt;客户端缓存（浏览器缓存、IOS缓存）&lt;/li&gt;
&lt;li&gt;DNS Resolver（/etc/resolv.conf 指定了系统查询的 DNS 服务器（通常是本地路由器或运营商 DNS））&lt;/li&gt;
&lt;li&gt;DNS 迭代查询流程（根域名服务器 -&amp;gt; 顶级域名服务器 -&amp;gt; 权威域名服务器（例如route 53））&lt;/li&gt;
&lt;li&gt;返回客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6cookiesessiontoken&#34;&gt;6.cookie、session、token
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存储位置不同
&lt;ul&gt;
&lt;li&gt;Cookie、Token 存储在客户端，Session存储在服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据安全性不同
&lt;ul&gt;
&lt;li&gt;Cookie 存储在客户端，容易被窃取，不安全&lt;/li&gt;
&lt;li&gt;Session 存储在服务器端，通过一个 Session ID 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露&lt;/li&gt;
&lt;li&gt;Token 通常使用加密算法生成，有效期较短且单向不可逆，可以提供较高的安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跨域支持不同
Cookie 、Session是不支持跨域传输的但 Token 可以轻松实现跨域。因为 Token 是存储在客户端的 localStorage 或者作为请求头的一部分发送到服务器的，所以不同的域名 Token 信息传输通常是不受影响的&lt;/li&gt;
&lt;li&gt;状态管理不同
&lt;ul&gt;
&lt;li&gt;Cookie 是在客户端存储的，客户端可以直接操作 Cookie 进行状态管理。&lt;/li&gt;
&lt;li&gt;Session 是在服务器端存储的，服务器通过 Session ID 来识别不同的用户会话。&lt;/li&gt;
&lt;li&gt;Token 是在客户端生成的，客户端需要在每次请求中携带 Token 进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用场景不同
&lt;ul&gt;
&lt;li&gt;Cookie 通常用于存储用户登录状态、记住用户偏好、保持登录状态。&lt;/li&gt;
&lt;li&gt;Session 适用于需要在服务器端存储用户状态的场景，购物车、表单提交等需要跟踪用户状态的场景。&lt;/li&gt;
&lt;li&gt;Token 适用于需要在客户端和服务器之间进行身份验证的场景，例如 API 访问控制、单点登录（SSO）、移动应用认证等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7http-状态码和原因&#34;&gt;7.http 状态码和原因
&lt;/h2&gt;&lt;p&gt;一些高频考察的状态码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;301 Moved Permanently：请求的资源已被永久移动到新的位置。常用于域名切换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;302 Found：临时重定向，请求的资源临时移动到新的位置。（浏览器常用于登录跳转）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;403 Forbidden。权限不足、有 Token 但没有权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;404 Not Found。请求的资源不存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;502 Bad Gateway。上游服务（Nginx → 应用）返回无效响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;504 Gateway Timeout。上游服务响应太慢（Nginx → 后端 timeout）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8linux-网络丢包排查&#34;&gt;8.linux 网络丢包排查
&lt;/h2&gt;&lt;p&gt;排查链路：
应用 → 系统 → 网络栈 → 网卡 → 云侧 → 外部链路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应用层是否丢包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查应用日志，查看是否有异常或错误信息。（超时、链接失败、接口qps 突增）&lt;/li&gt;
&lt;li&gt;模拟客户端curl/wget 直接测试&lt;/li&gt;
&lt;li&gt;通过 tcpdump 抓包验证 sudo tcpdump -i eth0 host &lt;peer-ip&gt; -w app.pcap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统层是否丢包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查网卡统计，ethtool -S eth0&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;rx_dropped&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;接收丢包&lt;/td&gt;
          &lt;td&gt;NIC 或内核队列满&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;rx_errors&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;接收错误&lt;/td&gt;
          &lt;td&gt;CRC、帧错误&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;tx_errors&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;发送错误&lt;/td&gt;
          &lt;td&gt;没发出去&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;rx_no_buffer&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;ring buffer 不够&lt;/td&gt;
          &lt;td&gt;压力大常见&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;rx_over_errors&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;接收队列溢出&lt;/td&gt;
          &lt;td&gt;系统瓶颈&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查 Linux 网络栈层丢包 netstat -s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查内核参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl net.core.rmem_default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl net.core.wmem_default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl net.core.netdev_max_backlog
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl net.ipv4.tcp_rmem
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysctl net.ipv4.tcp_wmem
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网卡队列（Ring buffer）丢包 ethtool -g eth0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cpu/中断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查网卡的配置参数，确保没有设置错误导致丢包。&lt;/li&gt;
&lt;li&gt;可以使用工具如 &lt;code&gt;ethtool&lt;/code&gt; 来查看网卡的统计信息，确认是否有丢包情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络路径丢包（云侧常见）
mtr -rwzbc 100 &lt;target-ip&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标端丢包（对方入口打满）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;本机
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpdump -i eth0 host &amp;lt;peer&amp;gt; -w local.pcap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;对端
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpdump -i eth0 host &amp;lt;your-ip&amp;gt; -w remote.pcap
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;9-长连接短连接websocket区别和使用场景&#34;&gt;9. 长连接、短连接、WebSocket区别和使用场景
&lt;/h2&gt;&lt;p&gt;短连接
客户端与服务器之间的连接在每次请求完成后立即关闭。这种方式在 HTTP/1.0 中是默认行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性请求的情况，比如获取静态资源（HTML、CSS、图片等）。&lt;/li&gt;
&lt;li&gt;对于不频繁交互的应用，短连接简单易用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;长连接
是指在一次 TCP 连接中，可以进行多次请求和响应，而不需要频繁地建立和关闭连接。这在 HTTP/1.1 中是默认行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要频繁交互的应用，例如在线聊天、实时更新的数据流（mysql、redis等）等。&lt;/li&gt;
&lt;li&gt;适合需要保持会话的场景，如电子商务网站中的购物车操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WebSocket
是一种在单个 TCP 连接上进行全双工通信的协议，允许服务器主动向客户端发送数据。支持双向通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实时应用，如在线游戏、股票行情、社交媒体即时消息等。&lt;/li&gt;
&lt;li&gt;需要即时反馈的应用，例如协作编辑工具、在线客服等。&lt;/li&gt;
&lt;li&gt;IoT（物联网）设备之间的实时通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-mac地址ip地址如何转换&#34;&gt;10. MAC地址IP地址如何转换
&lt;/h2&gt;&lt;p&gt;ARP作用就是通过ip地址查找后转换成MAC地址，通过ARP高速缓存表存储对应关系&lt;/p&gt;
&lt;p&gt;二层设备，发送数据帧
1、源主机先发送广播帧，将自己的IP地址和MAC地址带上，并且带上需要查找的IP地址
2、其他主机接收到后如果发现IP地址就是自己，就需要返回自己的IP地址和MAC地址，单播发送给源主机，并且在自己的高速缓存表中记录源主机的对应关系
3、源主机接收到后在高速缓存表中记录&lt;/p&gt;
&lt;h2 id=&#34;11-lvsnginxhaproxy区别和使用场景&#34;&gt;11. lvs、nginx、haproxy区别和使用场景
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;lvs 是基于 IP 层的负载均衡器，工作在 OSI 模型的第 4 层（传输层），主要用于负载均衡 TCP 和 UDP 流量。&lt;/li&gt;
&lt;li&gt;nginx 是一个高性能的 Web 服务器和反向代理服务器，也可以用作负载均衡器。它工作在 OSI 模型的第 7 层（应用层），主要用于处理 HTTP 和 HTTPS 请求。&lt;/li&gt;
&lt;li&gt;haproxy 是一个开源的负载均衡器，工作在 OSI 模型的第 7 层（应用层），主要用于负载均衡 HTTP 和 HTTPS 请求。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Sre</title>
        <link>http://localhost:1313/topic/interview/sre/</link>
        <pubDate>Thu, 04 Dec 2025 18:06:35 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/sre/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Sre" /&gt;&lt;h2 id=&#34;1-slaslosli&#34;&gt;1. SLA、SLO、SLI
&lt;/h2&gt;&lt;p&gt;SLI：服务水平指示器（正常响应数的百分比）&lt;/p&gt;
&lt;p&gt;SLO：服务水平目标（99%、99.999%、99.99999%）
必须和时间挂钩&lt;/p&gt;
&lt;p&gt;SLA：服务水平协议（SLO的具体实现）&lt;/p&gt;
&lt;p&gt;SLA 是对客户的外部承诺，SLO 是公司内部为实现承诺设定的目标，SLI 则是用来衡量实际服务表现的指标。&lt;/p&gt;
&lt;h2 id=&#34;2mttr&#34;&gt;2.MTTR
&lt;/h2&gt;&lt;p&gt;MTTR：平均故障修复时间（Mean Time to Repair）&lt;/p&gt;
&lt;p&gt;MTTR = 故障修复总时长 ÷ 故障次数&lt;/p&gt;
&lt;h3 id=&#34;如何降低-mttr&#34;&gt;如何降低 MTTR？
&lt;/h3&gt;&lt;h3 id=&#34;监控&#34;&gt;监控
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;完善监控告警体系
&lt;ul&gt;
&lt;li&gt;业务指标监控&lt;/li&gt;
&lt;li&gt;系统指标监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;告警降噪
&lt;ul&gt;
&lt;li&gt;告警分级：p1、p2、p3&lt;/li&gt;
&lt;li&gt;告警升级：当某告警等级为 P2，且在 1 小时内未被处理（未关闭、未屏蔽等），将自动升级为p 1&lt;/li&gt;
&lt;li&gt;告警间隔：同一条告警默认重复发送最小间隔时间为15m&lt;/li&gt;
&lt;li&gt;告警淹没：设置合适的告警策略，避免告警太多，告警漏报&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快速定位&#34;&gt;快速定位
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;标准化排障 SOP
&lt;ul&gt;
&lt;li&gt;CPU、内存飙高怎么查&lt;/li&gt;
&lt;li&gt;ELB 5xx 怎么查&lt;/li&gt;
&lt;li&gt;Pod CrashLoop 怎么查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动抓取现场信息
&lt;ul&gt;
&lt;li&gt;C++ core dump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;统一日志平台
&lt;ul&gt;
&lt;li&gt;ELK / Loki&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全链路追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快速修复问题&#34;&gt;快速修复问题
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;灰度发布 / 金丝雀发布&lt;/li&gt;
&lt;li&gt;配置中心(apollo) + 动态切流（像开关一样关闭某个模块）&lt;/li&gt;
&lt;li&gt;自动扩容（根据业务流量自动扩容，HPA）&lt;/li&gt;
&lt;li&gt;脚本化修复
&lt;ul&gt;
&lt;li&gt;一键重启&lt;/li&gt;
&lt;li&gt;一键清理DNS缓存&lt;/li&gt;
&lt;li&gt;&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高可用部署&#34;&gt;高可用部署
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高可用&lt;/li&gt;
&lt;li&gt;多AZ部署&lt;/li&gt;
&lt;li&gt;自动故障转移&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持续演练--可靠性测试&#34;&gt;持续演练 &amp;amp; 可靠性测试
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;混沌工程（提前演练故障）&lt;/li&gt;
&lt;li&gt;增加缺失监控点&lt;/li&gt;
&lt;li&gt;&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Liunx</title>
        <link>http://localhost:1313/topic/interview/liunx/</link>
        <pubDate>Wed, 03 Dec 2025 10:56:44 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/liunx/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Liunx" /&gt;&lt;h2 id=&#34;1-进程线程协程&#34;&gt;1. &lt;strong&gt;进程、线程、协程&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程：操作系统分配资源的最小单位，CPU、内存、磁盘IO，一个进程可以拥有多个线程。&lt;/li&gt;
&lt;li&gt;线程：进程内的执行单位，一个进程可以拥有多个线程，线程共享进程的资源。&lt;/li&gt;
&lt;li&gt;协程：用户态的轻量级线程，由用户程序控制，不需要操作系统的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-linux中的进程优先级与设置方法&#34;&gt;2. Linux中的进程优先级与设置方法
&lt;/h2&gt;&lt;p&gt;进程的优先级决定了其获取 CPU 时间片的顺序。优先级更高（数值更低）的进程会优先获取 CPU 时间片。
进程的优先级由 Nice 值表示，Nice 值的范围是 -20（最高优先级）到 19（最低优先级）。
默认情况下，进程的 Nice 值为 0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nice 命令：nice 命令用于启动一个进程，并设置其 Nice 值。例如，nice -n 10 command 会以 Nice 值为 10 来启动 command。&lt;/li&gt;
&lt;li&gt;renice 命令：renice 命令用于修改已经在运行的进程的 Nice 值。例如，renice +5 -p 1234 会将 PID 为 1234 的进程的 Nice 值增加 5。需要注意的是，只有 root 用户才能降低进程的 Nice 值。&lt;/li&gt;
&lt;li&gt;在代码中调用 nice() 或 setpriority() 函数：如果你正在编写一个程序，你可以在代码中调用 nice() 或 setpriority() 函数来改变你的进程的优先级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-什么是僵尸进程&#34;&gt;3. 什么是僵尸进程
&lt;/h2&gt;&lt;p&gt;僵尸进程是指一个已经终止运行的进程，但是其进程描述符（process descriptor）还在内存中。
父进程没有回收子进程的资源。&lt;/p&gt;
&lt;h2 id=&#34;4-什么进程中断&#34;&gt;4. 什么进程中断
&lt;/h2&gt;&lt;p&gt;中断是系统用来响应硬件设备请求的一种机制，会打断进程的正常调度和执行，然后调用内核的中断处理程序来响应设备的请求。
取外卖案例，不用苦苦等待，打电话的动作就是中断。
中断是一种异步处理机制，可以提高系统的并发处理能力。&lt;/p&gt;
&lt;h3 id=&#34;41-软中断硬中断不可中断进程&#34;&gt;4.1 软中断、硬中断、不可中断进程
&lt;/h3&gt;&lt;p&gt;Linux将中断分为两上半部分、下半部分
上半部分直接处理硬件请求，特点是快速执行（硬中断）
下半部分是由内核触发，特点是延迟执行（软中断）
不可中断进程表示进程和硬件正在交互，为了保持进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统IO存在问题。&lt;/p&gt;
&lt;h2 id=&#34;5-进程间通信的方式及其使用场景&#34;&gt;5. 进程间通信的方式及其使用场景
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;管道（Pipe）和命名管道（Named pipe）：管道是一种半双工的通信方式，主要用于具有父子关系的进程间。命名管道则是一种全双工的通信方式，可以用于任意两个进程间的通信。它们主要用于数据的流式传输。&lt;/li&gt;
&lt;li&gt;消息队列（Message Queue）：消息队列是一种列表结构，可以存储要发送的消息。进程可以向消息队列中添加消息，也可以从中读取消息。消息队列常用于不同进程间的数据交换和同步。&lt;/li&gt;
&lt;li&gt;共享内存（Shared Memory）：共享内存是最快的 IPC 方式，它允许两个或多个进程访问同一块内存区域。这种方式常用于大量数据的交换。&lt;/li&gt;
&lt;li&gt;信号（Signal）：信号是一种异步的通信方式，用于通知接收进程某个事件已经发生。例如，当一个进程结束时，它会发送一个 SIGCHLD 信号给其父进程。&lt;/li&gt;
&lt;li&gt;套接字（Socket）：套接字可以用于不同机器之间的进程通信，也可以用于同一机器上的进程通信。它支持 TCP、UDP 等多种协议，常用于网络通信。&lt;/li&gt;
&lt;li&gt;信号量（Semaphore）：信号量主要用于解决竞态条件，保护关键资源的访问。当多个进程需要访问同一资源时，可以使用信号量进行同步。&lt;/li&gt;
&lt;li&gt;文件锁（File Locking）：文件锁可以用于控制多个进程对同一文件的访问。当一个进程正在访问某个文件时，其他进程必须等待，直到该进程释放了文件锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-cgroup中限制cpu的方式有哪些&#34;&gt;6. cgroup中限制CPU的方式有哪些
&lt;/h2&gt;&lt;p&gt;cgroups, control groups（控制群组）的简写，是linux内核的一个功能，用来限制、控制与分离一个进程资源（如cpu、内存、磁盘等）。
在cgroup中，限制CPU的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于CPU时间片的限制：通过设置cpu.cfs_quota_us和cpu.cfs_period_us参数，限制进程在每个时间周期内可以使用的CPU时间。&lt;/li&gt;
&lt;li&gt;基于CPU核心的限制：通过设置cpu.shares参数，限制进程在多个CPU核心上的运行时间比例。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-内存中的buffers与cached的区别&#34;&gt;7. 内存中的buffers与cached的区别
&lt;/h2&gt;&lt;p&gt;设计目的，为了提升系统的I/O性能
Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。
Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。&lt;/p&gt;
&lt;p&gt;Buffers 是用于临时存储待写入硬盘的数据，而 Cached 是用于存储已经从硬盘读取的数据，以便快速访问。
Buffer 是对磁盘数据的缓存。而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。&lt;/p&gt;
&lt;p&gt;Linux是尽可能使用内存原则，内存会把剩余的空间申请为cache，而cache不属于free，当系统运行时间很长，我们会发现cache很大。&lt;/p&gt;
&lt;p&gt;当我们看到系统内存使用率很高，free几乎为0时，并不代表系统内存容量有瓶颈！只是系统充分发挥了内存作用。而当有进程需要申请大文件内存时，内核会将部分cache空间回收，回收的内存再分配给进程程序使用。&lt;/p&gt;
&lt;h2 id=&#34;8-栈内存和堆内存的区别&#34;&gt;8. 栈内存和堆内存的区别
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈内存（Stack）
特点：栈内存是自动分配和释放的，具有先进后出（LIFO，Last In First Out）的特性。栈内存中的变量会在函数调用时创建，并在函数返回时自动销毁。其管理由编译器控制，因此效率较高。
用途：通常用于存储局部变量、函数参数等临时数据。栈内存的分配通常很快，因为它只是调整一个指针来跟踪当前的栈顶位置。
优点：内存分配和释放速度快，不容易产生内存碎片。
缺点：栈内存的大小通常有限，不能用于存储大量数据或长时间使用的数据。&lt;/li&gt;
&lt;li&gt;堆内存（Heap）
特点：堆内存是动态分配的，大小不固定，需要程序员手动分配和释放。如果忘记释放，可能会导致内存泄漏。它没有严格的先进后出的顺序，可以在程序的任何位置请求内存分配。
用途：用于存储需要动态分配的大量数据，如对象、全局数据等。通过 malloc() 或 new 等操作分配，通过 free() 或 delete 等操作释放。
优点：适合长时间使用的数据或较大的数据结构，比如链表、树等。堆内存的大小相对栈来说几乎是无限的（受制于物理内存和系统限制）。
缺点：由于需要手动管理，堆内存分配和释放速度较慢，且容易导致内存碎片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区别总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生命周期：栈内存中的数据在函数调用期间有效，而堆内存的数据在手动释放前一直有效。&lt;/li&gt;
&lt;li&gt;分配方式：栈是由系统自动分配和管理，堆是由程序员动态分配和管理。&lt;/li&gt;
&lt;li&gt;效率：栈内存效率高，堆内存分配和释放较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-进程最大数最大线程数进程打开的文件数怎么调整&#34;&gt;9. 进程最大数、最大线程数、进程打开的文件数，怎么调整
&lt;/h2&gt;&lt;h3 id=&#34;查看当前限制&#34;&gt;查看当前限制
&lt;/h3&gt;&lt;p&gt;ulimit -a
ulimit -u      # 最大进程/线程数
ulimit -n      # 最大文件句柄数&lt;/p&gt;
&lt;h3 id=&#34;调整最大文件数&#34;&gt;调整最大文件数
&lt;/h3&gt;&lt;p&gt;临时生效
ulimit -n 65535&lt;/p&gt;
&lt;p&gt;永久生效
sudo vim /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;soft nofile 65535&lt;/li&gt;
&lt;li&gt;hard nofile 65535&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调整最大进程数--最大线程数&#34;&gt;调整最大进程数 / 最大线程数
&lt;/h3&gt;&lt;p&gt;临时生效
ulimit -u 65535&lt;/p&gt;
&lt;p&gt;永久生效
sudo vim /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;soft nproc 65535&lt;/li&gt;
&lt;li&gt;hard nproc 65535&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;注意事项
&lt;/h3&gt;&lt;p&gt;soft 软限制：用户可以超过这个值，但是不能超过hard限制。
hard 硬限制：用户不能超过这个值，也不能低于soft限制。&lt;/p&gt;
&lt;p&gt;/etc/sysctl.conf 属于系统级别内核参数，需要重启生效。
/etc/security/limits.conf 属于用户级别或者进程级别的参数，需要重新登录生效。&lt;/p&gt;
&lt;h2 id=&#34;10-load和cpu使用率区别&#34;&gt;10. load和cpu使用率区别
&lt;/h2&gt;&lt;p&gt;load 平均负载是指单位时间内，系统处于可运行状态（R）和不可中断状态的平均进程数（D）（平均活跃进程数）。
cpu 使用率是指单位时间内，CPU 正在处理的任务时间占总时间的比例。&lt;/p&gt;
&lt;p&gt;最理想的情况：平均负载等于CPU的个数，每一个核上都存在一个进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;查看CPU核心数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grep &lt;span class=&#34;s1&#34;&gt;&amp;#39;model name&amp;#39;&lt;/span&gt; /proc/cpuinfo &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; wc -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;uptime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 06:44:50 up &lt;span class=&#34;m&#34;&gt;190&lt;/span&gt; days, 22:44,  &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; users,  load average: 0.42, 0.14, 0.04
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;两者之间关系&#34;&gt;两者之间关系
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的&lt;/li&gt;
&lt;li&gt;I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高&lt;/li&gt;
&lt;li&gt;大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-du--df-查看磁盘结果不一致&#34;&gt;11. du 、 df 查看磁盘结果不一致
&lt;/h2&gt;&lt;p&gt;系统中可能存在大量被删除的文件（僵尸文件），且有运行的进程在使用这些文件的句柄。&lt;/p&gt;
&lt;p&gt;当一个文件被删除后，如果有进程仍然打开着该文件，du 不会统计这部分空间，因为文件已经从目录结构中移除；然而，df 会统计这部分空间，因为磁盘空间实际上还被占用。&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重启系统：重启系统可以清除所有未使用的文件句柄，包括僵尸文件。&lt;/li&gt;
&lt;li&gt;查找并关闭进程：使用 lsof 或 fuser 等工具查找并关闭使用僵尸文件的进程。
lsof |grep deleted&lt;/li&gt;
&lt;li&gt;手动删除文件：如果进程无法关闭，只能手动删除文件。但要注意，删除文件后，所有使用该文件的进程都将无法正常工作。&lt;/li&gt;
&lt;li&gt;杀死进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-硬链接和软链接区别&#34;&gt;12. 硬链接和软链接区别
&lt;/h2&gt;&lt;p&gt;硬链接和软链接是两种不同类型的文件系统链接，用于在目录之间共享文件。&lt;/p&gt;
&lt;h3 id=&#34;硬链接&#34;&gt;硬链接：
&lt;/h3&gt;&lt;p&gt;a. 具有相同inode节点号的多个文件互为硬链接文件；
b. 硬链接文件是文件的另一个入口
c. 可以通过给文件设置硬链接文件来防止重要文件被误删；
d. 删除硬链接文件或者删除源文件，文件实体不会被删除，只有都删除才会生效&lt;/p&gt;
&lt;h3 id=&#34;软连接&#34;&gt;软连接：
&lt;/h3&gt;&lt;p&gt;a. 软链接类似windows系统的快捷方式
b. 软链接里面存放的是源文件的路径，指向源文件
c. 删除源文件，软链接依然存在，但无法访问源文件内容
d. 软链接和源文件是不同的文件，文件类型也不同，inode号也不同；&lt;/p&gt;
&lt;h2 id=&#34;lvm怎么划分&#34;&gt;lvm怎么划分
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建物理卷（PV）&lt;/li&gt;
&lt;li&gt;创建卷组（VG）&lt;/li&gt;
&lt;li&gt;创建逻辑卷（LV）&lt;/li&gt;
&lt;li&gt;格式化逻辑卷（LV）&lt;/li&gt;
&lt;li&gt;挂载逻辑卷（LV）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在公有云运维中 很少见到 LVM 划分磁盘，这其实完全正常，而且是行业趋势。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;云盘可以直接扩容，不需要 LVM 的 PV/VG/LV&lt;/li&gt;
&lt;li&gt;传统 LVM 常用于RAID1（镜像）、RAID0（提升性能）。但是云盘底层已经多副本、且通过 SSD 提供高性能&lt;/li&gt;
&lt;li&gt;k8s 弱化了 LVM 的使用，根盘运行系统、数据放在PVC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-常见的raid有哪些使用场景是什么&#34;&gt;13. 常见的raid有哪些，使用场景是什么
&lt;/h2&gt;&lt;p&gt;常见的RAID级别有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAID 0：striping（条带化），将数据分成多个块，并行写入多个磁盘，提高读写速度。但不提供数据冗余，一旦磁盘故障，数据将丢失。&lt;/li&gt;
&lt;li&gt;RAID 1：mirroring（镜像），将数据在多个磁盘上进行镜像备份，提供数据冗余。但写入速度受限于较慢的磁盘。&lt;/li&gt;
&lt;li&gt;RAID 5：striping with parity（条带化加校验），将数据分成多个块，并行写入多个磁盘，同时在每个磁盘上存储校验信息。提供数据冗余和读写速度。&lt;/li&gt;
&lt;li&gt;RAID 6：striping with double parity（条带化加双校验），在RAID 5的基础上，增加一个校验信息，提供更高的数据冗余能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAID 0：用于对性能要求较高的场景，如数据库、视频编辑等。&lt;/li&gt;
&lt;li&gt;RAID 1：用于对数据冗余要求较高的场景，如企业关键数据存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14-如何创建和管理自定义systemd服务&#34;&gt;14. 如何创建和管理自定义systemd服务
&lt;/h2&gt;&lt;p&gt;自定义服务配置文件位置/etc/systemd/system/&lt;/p&gt;
&lt;p&gt;创建或者修改单元文件后需要重新加载配置生效
sudo systemctl daemon-reload&lt;/p&gt;
&lt;h2 id=&#34;15-linux-系统中proc是做什么的&#34;&gt;15. Linux 系统中/proc是做什么的
&lt;/h2&gt;&lt;p&gt;用户和内核交互的接口，性能工具数据（top、free、ps）的来源&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;启动当前进程完整命令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/proc/进程号/cmdline
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;当前进程的环境变量列表
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/proc/2422772/environ
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;/proc 文件输出是以在C语言及其衍生语言生成，需要分隔才能正常输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /proc/3824/cmdline &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; tr &lt;span class=&#34;s1&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;16-lsof命令使用场景&#34;&gt;16. lsof命令使用场景
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看某个进程打开的文件
lsof -p 1234&lt;/li&gt;
&lt;li&gt;查看哪个进程正在使用特定端口
lsof -i :80&lt;/li&gt;
&lt;li&gt;查看所有网络连接
lsof -i&lt;/li&gt;
&lt;li&gt;查看某个用户打开文件
lsof -u username&lt;/li&gt;
&lt;li&gt;文件已经被删除，但仍然被某个进程占用
lsof | grep deleted&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>面试专题的一些规划</title>
        <link>http://localhost:1313/topic/interview/structure/</link>
        <pubDate>Tue, 02 Dec 2025 15:06:33 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/structure/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post 面试专题的一些规划" /&gt;&lt;ul&gt;
&lt;li&gt;面试经历&lt;/li&gt;
&lt;li&gt;liunx&lt;/li&gt;
&lt;li&gt;container &amp;amp;&amp;amp; k8s&lt;/li&gt;
&lt;li&gt;network&lt;/li&gt;
&lt;li&gt;database&lt;/li&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;program&lt;/li&gt;
&lt;li&gt;SRE&lt;/li&gt;
&lt;li&gt;&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试题来自崔亮的博客&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cuiliangblog.cn/detail/article/89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cuiliangblog.cn/detail/article/89&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
