<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>面试 on hangliuc</title>
        <link>http://localhost:1313/topic/interview/</link>
        <description>Recent content in 面试 on hangliuc</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Wed, 03 Dec 2025 10:56:44 +0800</lastBuildDate><atom:link href="http://localhost:1313/topic/interview/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Liunx</title>
        <link>http://localhost:1313/topic/interview/liunx/</link>
        <pubDate>Wed, 03 Dec 2025 10:56:44 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/liunx/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post Liunx" /&gt;&lt;h2 id=&#34;1-进程线程协程&#34;&gt;1. &lt;strong&gt;进程、线程、协程&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程：操作系统分配资源的最小单位，CPU、内存、磁盘IO，一个进程可以拥有多个线程。&lt;/li&gt;
&lt;li&gt;线程：进程内的执行单位，一个进程可以拥有多个线程，线程共享进程的资源。&lt;/li&gt;
&lt;li&gt;协程：用户态的轻量级线程，由用户程序控制，不需要操作系统的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-linux中的进程优先级与设置方法&#34;&gt;2. Linux中的进程优先级与设置方法
&lt;/h2&gt;&lt;p&gt;进程的优先级决定了其获取 CPU 时间片的顺序。优先级更高（数值更低）的进程会优先获取 CPU 时间片。
进程的优先级由 Nice 值表示，Nice 值的范围是 -20（最高优先级）到 19（最低优先级）。
默认情况下，进程的 Nice 值为 0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nice 命令：nice 命令用于启动一个进程，并设置其 Nice 值。例如，nice -n 10 command 会以 Nice 值为 10 来启动 command。&lt;/li&gt;
&lt;li&gt;renice 命令：renice 命令用于修改已经在运行的进程的 Nice 值。例如，renice +5 -p 1234 会将 PID 为 1234 的进程的 Nice 值增加 5。需要注意的是，只有 root 用户才能降低进程的 Nice 值。&lt;/li&gt;
&lt;li&gt;在代码中调用 nice() 或 setpriority() 函数：如果你正在编写一个程序，你可以在代码中调用 nice() 或 setpriority() 函数来改变你的进程的优先级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-什么是僵尸进程&#34;&gt;3. 什么是僵尸进程
&lt;/h2&gt;&lt;p&gt;僵尸进程是指一个已经终止运行的进程，但是其进程描述符（process descriptor）还在内存中。
父进程没有回收子进程的资源。&lt;/p&gt;
&lt;h2 id=&#34;4-什么进程中断&#34;&gt;4. 什么进程中断
&lt;/h2&gt;&lt;p&gt;中断是系统用来响应硬件设备请求的一种机制，会打断进程的正常调度和执行，然后调用内核的中断处理程序来响应设备的请求。
取外卖案例，不用苦苦等待，打电话的动作就是中断。
中断是一种异步处理机制，可以提高系统的并发处理能力。&lt;/p&gt;
&lt;h3 id=&#34;41-软中断硬中断不可中断进程&#34;&gt;4.1 软中断、硬中断、不可中断进程
&lt;/h3&gt;&lt;p&gt;Linux将中断分为两上半部分、下半部分
上半部分直接处理硬件请求，特点是快速执行（硬中断）
下半部分是由内核触发，特点是延迟执行（软中断）
不可中断进程表示进程和硬件正在交互，为了保持进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统IO存在问题。&lt;/p&gt;
&lt;h2 id=&#34;5-进程间通信的方式及其使用场景&#34;&gt;5. 进程间通信的方式及其使用场景
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;管道（Pipe）和命名管道（Named pipe）：管道是一种半双工的通信方式，主要用于具有父子关系的进程间。命名管道则是一种全双工的通信方式，可以用于任意两个进程间的通信。它们主要用于数据的流式传输。&lt;/li&gt;
&lt;li&gt;消息队列（Message Queue）：消息队列是一种列表结构，可以存储要发送的消息。进程可以向消息队列中添加消息，也可以从中读取消息。消息队列常用于不同进程间的数据交换和同步。&lt;/li&gt;
&lt;li&gt;共享内存（Shared Memory）：共享内存是最快的 IPC 方式，它允许两个或多个进程访问同一块内存区域。这种方式常用于大量数据的交换。&lt;/li&gt;
&lt;li&gt;信号（Signal）：信号是一种异步的通信方式，用于通知接收进程某个事件已经发生。例如，当一个进程结束时，它会发送一个 SIGCHLD 信号给其父进程。&lt;/li&gt;
&lt;li&gt;套接字（Socket）：套接字可以用于不同机器之间的进程通信，也可以用于同一机器上的进程通信。它支持 TCP、UDP 等多种协议，常用于网络通信。&lt;/li&gt;
&lt;li&gt;信号量（Semaphore）：信号量主要用于解决竞态条件，保护关键资源的访问。当多个进程需要访问同一资源时，可以使用信号量进行同步。&lt;/li&gt;
&lt;li&gt;文件锁（File Locking）：文件锁可以用于控制多个进程对同一文件的访问。当一个进程正在访问某个文件时，其他进程必须等待，直到该进程释放了文件锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-cgroup中限制cpu的方式有哪些&#34;&gt;6. cgroup中限制CPU的方式有哪些
&lt;/h2&gt;&lt;p&gt;cgroups, control groups（控制群组）的简写，是linux内核的一个功能，用来限制、控制与分离一个进程资源（如cpu、内存、磁盘等）。
在cgroup中，限制CPU的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于CPU时间片的限制：通过设置cpu.cfs_quota_us和cpu.cfs_period_us参数，限制进程在每个时间周期内可以使用的CPU时间。&lt;/li&gt;
&lt;li&gt;基于CPU核心的限制：通过设置cpu.shares参数，限制进程在多个CPU核心上的运行时间比例。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-内存中的buffers与cached的区别&#34;&gt;7. 内存中的buffers与cached的区别
&lt;/h2&gt;&lt;p&gt;设计目的，为了提升系统的I/O性能
Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。
Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。&lt;/p&gt;
&lt;p&gt;Buffers 是用于临时存储待写入硬盘的数据，而 Cached 是用于存储已经从硬盘读取的数据，以便快速访问。
Buffer 是对磁盘数据的缓存。而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。&lt;/p&gt;
&lt;p&gt;Linux是尽可能使用内存原则，内存会把剩余的空间申请为cache，而cache不属于free，当系统运行时间很长，我们会发现cache很大。&lt;/p&gt;
&lt;p&gt;当我们看到系统内存使用率很高，free几乎为0时，并不代表系统内存容量有瓶颈！只是系统充分发挥了内存作用。而当有进程需要申请大文件内存时，内核会将部分cache空间回收，回收的内存再分配给进程程序使用。&lt;/p&gt;
&lt;h2 id=&#34;8-栈内存和堆内存的区别&#34;&gt;8. 栈内存和堆内存的区别
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈内存（Stack）
特点：栈内存是自动分配和释放的，具有先进后出（LIFO，Last In First Out）的特性。栈内存中的变量会在函数调用时创建，并在函数返回时自动销毁。其管理由编译器控制，因此效率较高。
用途：通常用于存储局部变量、函数参数等临时数据。栈内存的分配通常很快，因为它只是调整一个指针来跟踪当前的栈顶位置。
优点：内存分配和释放速度快，不容易产生内存碎片。
缺点：栈内存的大小通常有限，不能用于存储大量数据或长时间使用的数据。&lt;/li&gt;
&lt;li&gt;堆内存（Heap）
特点：堆内存是动态分配的，大小不固定，需要程序员手动分配和释放。如果忘记释放，可能会导致内存泄漏。它没有严格的先进后出的顺序，可以在程序的任何位置请求内存分配。
用途：用于存储需要动态分配的大量数据，如对象、全局数据等。通过 malloc() 或 new 等操作分配，通过 free() 或 delete 等操作释放。
优点：适合长时间使用的数据或较大的数据结构，比如链表、树等。堆内存的大小相对栈来说几乎是无限的（受制于物理内存和系统限制）。
缺点：由于需要手动管理，堆内存分配和释放速度较慢，且容易导致内存碎片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区别总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生命周期：栈内存中的数据在函数调用期间有效，而堆内存的数据在手动释放前一直有效。&lt;/li&gt;
&lt;li&gt;分配方式：栈是由系统自动分配和管理，堆是由程序员动态分配和管理。&lt;/li&gt;
&lt;li&gt;效率：栈内存效率高，堆内存分配和释放较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-进程最大数最大线程数进程打开的文件数怎么调整&#34;&gt;9. 进程最大数、最大线程数、进程打开的文件数，怎么调整
&lt;/h2&gt;&lt;h3 id=&#34;查看当前限制&#34;&gt;查看当前限制
&lt;/h3&gt;&lt;p&gt;ulimit -a
ulimit -u      # 最大进程/线程数
ulimit -n      # 最大文件句柄数&lt;/p&gt;
&lt;h3 id=&#34;调整最大文件数&#34;&gt;调整最大文件数
&lt;/h3&gt;&lt;p&gt;临时生效
ulimit -n 65535&lt;/p&gt;
&lt;p&gt;永久生效
sudo vim /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;soft nofile 65535&lt;/li&gt;
&lt;li&gt;hard nofile 65535&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调整最大进程数--最大线程数&#34;&gt;调整最大进程数 / 最大线程数
&lt;/h3&gt;&lt;p&gt;临时生效
ulimit -u 65535&lt;/p&gt;
&lt;p&gt;永久生效
sudo vim /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;soft nproc 65535&lt;/li&gt;
&lt;li&gt;hard nproc 65535&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;注意事项
&lt;/h3&gt;&lt;p&gt;soft 软限制：用户可以超过这个值，但是不能超过hard限制。
hard 硬限制：用户不能超过这个值，也不能低于soft限制。&lt;/p&gt;
&lt;p&gt;/etc/sysctl.conf 属于系统级别内核参数，需要重启生效。
/etc/security/limits.conf 属于用户级别或者进程级别的参数，需要重新登录生效。&lt;/p&gt;
&lt;h2 id=&#34;10-load和cpu使用率区别&#34;&gt;10. load和cpu使用率区别
&lt;/h2&gt;&lt;p&gt;load 平均负载是指单位时间内，系统处于可运行状态（R）和不可中断状态的平均进程数（D）（平均活跃进程数）。
cpu 使用率是指单位时间内，CPU 正在处理的任务时间占总时间的比例。&lt;/p&gt;
&lt;p&gt;最理想的情况：平均负载等于CPU的个数，每一个核上都存在一个进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;查看CPU核心数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grep &lt;span class=&#34;s1&#34;&gt;&amp;#39;model name&amp;#39;&lt;/span&gt; /proc/cpuinfo &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; wc -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;uptime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 06:44:50 up &lt;span class=&#34;m&#34;&gt;190&lt;/span&gt; days, 22:44,  &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; users,  load average: 0.42, 0.14, 0.04
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;两者之间关系&#34;&gt;两者之间关系
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的&lt;/li&gt;
&lt;li&gt;I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高&lt;/li&gt;
&lt;li&gt;大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-du--df-查看磁盘结果不一致&#34;&gt;11. du 、 df 查看磁盘结果不一致
&lt;/h2&gt;&lt;p&gt;系统中可能存在大量被删除的文件（僵尸文件），且有运行的进程在使用这些文件的句柄。&lt;/p&gt;
&lt;p&gt;当一个文件被删除后，如果有进程仍然打开着该文件，du 不会统计这部分空间，因为文件已经从目录结构中移除；然而，df 会统计这部分空间，因为磁盘空间实际上还被占用。&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重启系统：重启系统可以清除所有未使用的文件句柄，包括僵尸文件。&lt;/li&gt;
&lt;li&gt;查找并关闭进程：使用 lsof 或 fuser 等工具查找并关闭使用僵尸文件的进程。
lsof |grep deleted&lt;/li&gt;
&lt;li&gt;手动删除文件：如果进程无法关闭，只能手动删除文件。但要注意，删除文件后，所有使用该文件的进程都将无法正常工作。&lt;/li&gt;
&lt;li&gt;杀死进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-硬链接和软链接区别&#34;&gt;12. 硬链接和软链接区别
&lt;/h2&gt;&lt;p&gt;硬链接和软链接是两种不同类型的文件系统链接，用于在目录之间共享文件。&lt;/p&gt;
&lt;h3 id=&#34;硬链接&#34;&gt;硬链接：
&lt;/h3&gt;&lt;p&gt;a. 具有相同inode节点号的多个文件互为硬链接文件；
b. 硬链接文件是文件的另一个入口
c. 可以通过给文件设置硬链接文件来防止重要文件被误删；
d. 删除硬链接文件或者删除源文件，文件实体不会被删除，只有都删除才会生效&lt;/p&gt;
&lt;h3 id=&#34;软连接&#34;&gt;软连接：
&lt;/h3&gt;&lt;p&gt;a. 软链接类似windows系统的快捷方式
b. 软链接里面存放的是源文件的路径，指向源文件
c. 删除源文件，软链接依然存在，但无法访问源文件内容
d. 软链接和源文件是不同的文件，文件类型也不同，inode号也不同；&lt;/p&gt;
&lt;h2 id=&#34;lvm怎么划分&#34;&gt;lvm怎么划分
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建物理卷（PV）&lt;/li&gt;
&lt;li&gt;创建卷组（VG）&lt;/li&gt;
&lt;li&gt;创建逻辑卷（LV）&lt;/li&gt;
&lt;li&gt;格式化逻辑卷（LV）&lt;/li&gt;
&lt;li&gt;挂载逻辑卷（LV）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在公有云运维中 很少见到 LVM 划分磁盘，这其实完全正常，而且是行业趋势。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;云盘可以直接扩容，不需要 LVM 的 PV/VG/LV&lt;/li&gt;
&lt;li&gt;传统 LVM 常用于RAID1（镜像）、RAID0（提升性能）。但是云盘底层已经多副本、且通过 SSD 提供高性能&lt;/li&gt;
&lt;li&gt;k8s 弱化了 LVM 的使用，根盘运行系统、数据放在PVC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-常见的raid有哪些使用场景是什么&#34;&gt;13. 常见的raid有哪些，使用场景是什么
&lt;/h2&gt;&lt;p&gt;常见的RAID级别有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAID 0：striping（条带化），将数据分成多个块，并行写入多个磁盘，提高读写速度。但不提供数据冗余，一旦磁盘故障，数据将丢失。&lt;/li&gt;
&lt;li&gt;RAID 1：mirroring（镜像），将数据在多个磁盘上进行镜像备份，提供数据冗余。但写入速度受限于较慢的磁盘。&lt;/li&gt;
&lt;li&gt;RAID 5：striping with parity（条带化加校验），将数据分成多个块，并行写入多个磁盘，同时在每个磁盘上存储校验信息。提供数据冗余和读写速度。&lt;/li&gt;
&lt;li&gt;RAID 6：striping with double parity（条带化加双校验），在RAID 5的基础上，增加一个校验信息，提供更高的数据冗余能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAID 0：用于对性能要求较高的场景，如数据库、视频编辑等。&lt;/li&gt;
&lt;li&gt;RAID 1：用于对数据冗余要求较高的场景，如企业关键数据存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14-如何创建和管理自定义systemd服务&#34;&gt;14. 如何创建和管理自定义systemd服务
&lt;/h2&gt;&lt;p&gt;自定义服务配置文件位置/etc/systemd/system/&lt;/p&gt;
&lt;p&gt;创建或者修改单元文件后需要重新加载配置生效
sudo systemctl daemon-reload&lt;/p&gt;
&lt;h2 id=&#34;15-linux-系统中proc是做什么的&#34;&gt;15. Linux 系统中/proc是做什么的
&lt;/h2&gt;&lt;p&gt;用户和内核交互的接口，性能工具数据（top、free、ps）的来源&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;启动当前进程完整命令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/proc/进程号/cmdline
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;当前进程的环境变量列表
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/proc/2422772/environ
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;/proc 文件输出是以在C语言及其衍生语言生成，需要分隔才能正常输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /proc/3824/cmdline &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; tr &lt;span class=&#34;s1&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;16-lsof命令使用场景&#34;&gt;16. lsof命令使用场景
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看某个进程打开的文件
lsof -p 1234&lt;/li&gt;
&lt;li&gt;查看哪个进程正在使用特定端口
lsof -i :80&lt;/li&gt;
&lt;li&gt;查看所有网络连接
lsof -i&lt;/li&gt;
&lt;li&gt;查看某个用户打开文件
lsof -u username&lt;/li&gt;
&lt;li&gt;文件已经被删除，但仍然被某个进程占用
lsof | grep deleted&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>面试专题的一些规划</title>
        <link>http://localhost:1313/topic/interview/structure/</link>
        <pubDate>Tue, 02 Dec 2025 15:06:33 +0800</pubDate>
        
        <guid>http://localhost:1313/topic/interview/structure/</guid>
        <description>&lt;img src="http://localhost:1313/img/interview_cover.jpg" alt="Featured image of post 面试专题的一些规划" /&gt;&lt;ul&gt;
&lt;li&gt;面试经历&lt;/li&gt;
&lt;li&gt;liunx&lt;/li&gt;
&lt;li&gt;container &amp;amp;&amp;amp; k8s&lt;/li&gt;
&lt;li&gt;network&lt;/li&gt;
&lt;li&gt;database&lt;/li&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;program&lt;/li&gt;
&lt;li&gt;SRE&lt;/li&gt;
&lt;li&gt;&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试题来自崔亮的博客&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cuiliangblog.cn/detail/article/89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cuiliangblog.cn/detail/article/89&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
